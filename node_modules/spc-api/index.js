"use strict";

const Spc = require('./lib/core.js');
const st = require('./lib/spc_tables.js');

const Homey = require('homey');
//const locale = Homey.ManagerI18n.getLanguage();
const locale = 'en';

var debugOn = true;
var panels = {};
var deviceQueue = [];
var panelSearch;


// Debug logging
function debug() {
    if (debugOn) {
        var now = new Date();
        var itemdebug = (x) => {
            return (typeof x === 'object' ? JSON.stringify(x) : x) + ' '
        };
        var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
        var ms = ('00' + now.getMilliseconds()).slice(-3);
        var text = '';
        for (var i = 0; i < arguments.length; i++) {
            var x = arguments[i];
            if (Object.prototype.toString.call(arguments[i]) === '[object Arguments]') {
                for (var j = 0; j < x.length; j++) {
                    text += itemdebug(x[j]);
                }
            } else {
                text += itemdebug(x);
            }
        }
        Homey.app.log(time + '.' + ms, text.slice(0, -1));
    }
}

// Add devices to the queue if the panel is not active yet
function addToQueue(panel, data) {
    // Panel not added yet...
    if (deviceQueue[panel] == null) {
        deviceQueue[panel] = [];
    }
    // or no panel at all?
    data.driver.getDevice(data.device).setUnavailable(Homey.__('error.no_panel'));
    deviceQueue[panel].push(data);
}

// Check if device is already added in Homey
function deviceIsAdded(panel, type, id) {
    if (panels[panel] != null) {
        for (var i = 0; i < panels[panel].children.length; i++) {
            if (type == 'sensor' &&
                panels[panel].children[i].type == type &&
                Number(panels[panel].children[i].device.zone) == Number(id)) {
                return true;
            } else if (type == 'area' && 
                panels[panel].children[i].type == type &&
                Number(panels[panel].children[i].device.area) == Number(id)) {
                return true;
            }
        }
    }
    return false;
}

var self = module.exports = {
    // debug function
    debug: debug,

    // turn debugging on/off
    setDebug: function(on_off) {
        debugOn = on_off;
    },

    // Add a new panel or search for one
    addPanel: function(driver, device, name, settings) {
        // During a search there is no device id yet
        var id = device == null ? null : device.id;
        var search = settings.bridge_ip + ':' + settings.bridge_port;
        var err = null;
        if (panels[id] != null) {
            err = Homey.__('error.already_present', {
                panel: id
            });
        } else {
            // Check all panels whether there is already one on this ip:port
            for (var p in panels) {
                var pip = panels[p].settings.ip + ':' + panels[p].settings.port;
                if (search == pip) {
                    search += ' (' + p + ')';
                    err = Homey.__('error.already_present', {
                        panel: search
                    });
                }
            }
        }
        if (err != null) {
            debug(err);
            Homey.emit('found', {
                found: false,
                err: err
            });
            return err;
        }
        var spc = new Spc(id, settings, debug);
        if (device != null) { // ID is correct, not a search
            panels[id] = {
                spc: spc,
                name: name,
                settings: settings, // device settings
                state: {},
                children: []
            }
            // Register handlers
            self.addPanelActions(driver, device);
        } else {
            panelSearch = spc;
        }

        // Add event handlers
        spc.events.on('communication', function(status) {
            if (id != null && panels[id] != null && panels[id].spc.readAllSettings) {
                debug('Handle communication event', status);
                if (status == 'open') { 
                    if (panels[id].spc.readAllStatus) {
                        self.setDevicesAvailableMark(id, driver, device, true);
                    }
                } else {
                    self.setDevicesAvailableMark(id, driver, device, false);
                }
            }
        });

        spc.events.on('found', function(data) {
            debug('found', data);
            if (id != null) {
                data.id = id;
                var available = (panels[id] == null ? false : panels[id].available);
                if (!data.found && available != false) {
                    self.setDevicesAvailableMark(id, driver, device, false);
                } else if (data.found && !available) {
                    debug('Marking panel', id, 'as available');
                    self.setDevicesAvailableMark(id, driver, device, true);
                }
            }
            Homey.emit('found', data);
        });

        spc.events.on('download', function(state) {
            // Only relevant when we are searching for a panel
            if (panelSearch != null) {
                debug('download searching for a panel');

                var data = {
                    state: state,
                    id: id,
                    show: {}
                };
                id = spc.settings.config.panelSerial;
                data.id = id;
                panels[id] = {
                    spc: spc,
                    name: name,
                    settings: settings,
                    state: {},
                    children: []
                }
                // Build up the information we show in the front-end
                for (var i in spc.info) {
                    var item = spc.info[i];
                    var val = spc.settings.config[item.val];
                    if (val != null) {
                        data.show[i] = {
                            name: item[locale],
                            val: val
                        };
                    }
                }
                // If download completed, add panel
                if (state == 'done') {
                    // Add read-only settings
                    var cfg = spc.settings.config;
                    settings.type = cfg.panelType;
                    settings.model = cfg.panelModel;
                    settings.serial = cfg.panelSerial;
                    settings.firmware = cfg.panelSoftware;
                    data.device = {
                        name: spc.settings.config.panelType,
                        data: {
                            id: id
                        },
                        settings: settings
                    }
                    // Update our local variable as well
                    device = data.device.data;
                    // Register handlers
                    self.addPanelActions(driver, device);
                    // Add zone information to show
                    data.show['headers'] = ['Zone', 'Name', 'Type'];
                    data.show['rows'] = [];
                    for (var z in spc.settings.zones) {
                        var zone = spc.settings.zones[z];
                        let sname = zone.sname ? '[' + zone.sname + '] ' : ''
                        var row = [z, zone.zname, zone.ztypeName];
                        data.show['rows'].push(row);
                    }
                }
                // Let front-end know of updated info
                Homey.emit('download', data);
            } else {
                // Regular download, not for adding panel
                if (state == 'done' && panels[id] != null) {
                    // Open websockets connection to SPC Bridge and get current status
                    panels[id].spc.openWsConnection(function(err, success) {
                        if (success) {
                            // Activate registered children
                            if (panels[id].children != null) {
                                var listAreas = panels[id].spc.settings.areas;
                                var listZones = panels[id].spc.settings.zones;
                                for (var i = 0; i < panels[id].children.length; i++) {
                                    var sensor = panels[id].children[i];
                                    if (sensor.type == 'sensor') {
                                        var elem = listZones[sensor.device.zone];
                                        if (elem == null) {
                                            // Sensor has been removed from panel
                                            sensor.driver.getDevice(sensor.device).setUnavailable(Homey.__('error.sensor_removed'));
                                        } else {
                                            sensor.driver.getDevice(sensor.device).setAvailable();
                                            // Update sensor setting info
                                            var setting = {
                                                name: elem.zname,
                                                type: elem.ztypeName,
                                                area: elem.area_name
                                            };
                                            sensor.driver.getDevice(sensor.device).setSettings(setting);
                                        }
                                    } else if (sensor.type == 'area') {
                                        var elem = listAreas[sensor.device.area];
                                        if (elem == null) {
                                            // Sensor has been removed from panel
                                            sensor.driver.getDevice(sensor.device).setUnavailable(Homey.__('error.sensor_removed'));
                                        } else {
                                            sensor.driver.getDevice(sensor.device).setAvailable();
                                            // Update sensor setting info
                                            var setting = {
                                                area_id: elem.area_id,
                                                area_name: elem.area_name
                                            };
                                            sensor.driver.getDevice(sensor.device).setSettings(setting);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
        });
        return err;
    },

    // Add panel actions & child device actions
    addPanelActions: function(driver, device) {
        var id = device.id;
        if (panels[id] != null) {
            debug('Adding panel events for', id);
            // Catch system events
            panels[id].spc.events.on('system', function(field, newVal, curVal) {
                debug('System event', field, 'with new value: ', newVal, ', current value: ', curVal);

                var cur = undefined;
                if (curVal != undefined) cur = curVal.value;
                if (field == 'arm_mode') {
                    // arm_mode: 0 = All Unset, 1 = All Partset A, 2 = All PartsetB, 3 = All Fullset, 99 = Partly Set
                    var detail = st.spcAreaModes[newVal.value];
                    var detailTxt = st.spcAreaModesText[locale][detail];
                    driver.getDevice(device).setCapabilityValue('arm_mode', detailTxt, function(err, success) {
                        debug('Capability system arm_mode update:', detailTxt, id, (err ? err : 'OK'));
                    });
                    driver.triggerPanelModeTo(driver.getDevice(device), {}, {value:newVal.value, current:cur});
                    driver.triggerPanelModeFrom(driver.getDevice(device), {}, {value:newVal.value, current:cur});

                } else if (field == 'alarm') {
                    driver.getDevice(device).setCapabilityValue('alarm', newVal.value, function(err, success) {
                        debug('Capability system alarm state update:', newVal, curVal, id, (err ? err : 'OK'));
                    });
                    if (curVal != undefined && curVal.value != newVal.value) {
                        if (newVal.value) {
                            driver.triggerPanelAlarmOn(driver.getDevice(device), {}, {});
                        } else {
                            driver.triggerPanelAlarmOff(driver.getDevice(device), {}, {});
                        }
                    }
                }
            });
        }
        // Add devices in the queue (if any)
        if (deviceQueue[id] != null) {
            for (var i = 0; i < deviceQueue[id].length; i++) {
                var q = deviceQueue[id][i];
                if (q.type == 'sensor') {
                    self.addSensorDevice(q.driver, q.device, q.name);
                } else if (q.type == 'area') {
                    self.addAreaDevice(q.driver, q.device, q.name);
                } else {
                    self.addOutputDevice(q.driver, q.device, q.name);
                }
                q.driver.getDevice(q.device).setAvailable();
            }
        }
    },

    // Cancel a panel search in progress
    stopPanelSearch: function(complete) {
        if (!complete && panelSearch != null) {
            panelSearch.found = 'no'; // make sure we don't re-open the connection
            if (panelSearch.settings != null) {
                // Panel already registered, remove it
                delete panels[panelSearch.settings.config.panelSerial];
            } else {

            }
        }
        panelSearch = null;
    },

    // Open Websockets connectiion to SPC Gateway
    openWsConnection: function(id, callback) {
        if (panels[id] != null) {
            panels[id].spc.openWsConnection(callback);
        } else {
            callback('panel not found', null);
        }
    },

    // Close Websockets connectiion to SPC Gateway
    closeWsConnection: function(id) {
        if (panels[id] != null && panels[id].spc) {
            panels[id].spc.closeWsConnection();
        }
    },

    // Remove a panel
    deletePanel: function(id) {
        if (panels[id] != null) {
            debug('Delete panel', id);
            panels[id].spc.found = 'no'; // make sure we don't re-open the connection
            panels[id].spc.closeWsConnection(function(err, success) {
                // mark all devices as unavailable
                if (panels[id].children != null) {
                    for (var i = 0; i < panels[id].children.length; i++) {
                        panels[id].children[i].driver.getDevice(panels[id].children[i].device).setUnavailable(Homey.__('error.no_panel'));
                    }
                }
                delete panels[id];
            });
        } else {
            debug('Error: panel', id, 'not present.');
        }
    },

    // Get a list of all registered panels
    getPanels: function() {
        var list = [];
        for (var item in panels) {
            var elem = panels[item].spc.settings.config;
            list.push({
                id: item,
                type: elem.panelType,
                name: elem.panelModel,
                serial: elem.panelSerial,
                hname: panels[item].name
            });
        }
        return list;
    },

    // Get all area and zone status from SPC panel 
    getAllStatus: function(id) {
        if (panels[id] != null) {
            panels[id].spc.getAllStatus(function(err, success) {
            });
        }
    },

    // Update the end-user name of the panel
    updatePanelName: function(id, name) {
        if (panels[id] != null) {
            panels[id].name = name;
        }
    },

    // Mark devices as available/unavailable
    setDevicesAvailableMark: function(id, driver, device, available) {
        if (panels[id] != null && driver.getDevice(device)) {
            panels[id].available = available;
            if (!available) {
                driver.getDevice(device).setUnavailable(Homey.__('error.unreachable', {
                    time: new Date().toLocaleString(locale)
                }));
                for (var i = 0; i < panels[id].children.length; i++) {
                    var child = panels[id].children[i];
                    child.driver.getDevice(child.device).setUnavailable(Homey.__('error.no_panel'));
                }
            } else {
                driver.getDevice(device).setAvailable();
                for (var i = 0; i < panels[id].children.length; i++) {
                    var child = panels[id].children[i];
                    child.driver.getDevice(child.device).setAvailable();
                }
            }
        }
    },

    // Update the end-user name of the panel
    reconnectPanel: function(device, newSettings, callback) {
        var panel = device.getData().id;
        if (panels[panel] != null && panels[panel].spc != null) {
            var spc = panels[panel].spc;
            spc.devSettings = newSettings;
            spc.closeWsConnection(function(err, success) {
                spc.openWsConnection(function(err, success) {
                    if (success) {
                        self.setDevicesAvailableMark(panel, device.getDriver(), device.getData(), true);
                        callback(null, 'New settings saved and reconnecton to SPC Bridge succeeded');
                    } else {
                        self.setDevicesAvailableMark(panel, device.getDriver(), device.getData(), false);
                        callback(null, 'Failed to connect to SPC Bridge');
                    }
                });
            });
        }
    },

    // Get the value of a panel variable
    getPanelValue: function(panel, name) {
        var val = null;
        if (panels[panel] != null && panels[panel].spc.system['system']) {
            if (name == 'arm_mode_value' && panels[panel].spc.system['system']['arm_mode']) {
                val = panels[panel].spc.system['system']['arm_mode'].value;
            } else if (name == 'arm_mode' && panels[panel].spc.system['system']['arm_mode']) {
                var mode = panels[panel].spc.system['system']['arm_mode'].value;
                var detail = st.spcAreaModes[mode];
                val = st.spcAreaModesText[locale][detail];
           } else if (name == 'alarm' && panels[panel].spc.system['system']['alarm']) {
                val = panels[panel].spc.system['system']['alarm'].value;
           }
        }
        return val;
    },

    // Set the arm mode of the panel
    setPanelArmMode: function(panel, mode, callback) {
        if (panels[panel] != null) {
            for (var area in panels[panel].spc.settings.areas) {
                var allowed = true;   // TODO Handle allow variable
                if (area > 0 && allowed && panels[panel].spc.readAllSettings) {
                    panels[panel].spc.sendCommand('area/' + area + '/' + mode, function(err, success) {
                       callback(err, success);
                    });
                } else {
                    callback('Not allowed');
                }
            }
        } else {
            callback('Panel does not exist');
        }
    },

    // Get the value of an area variable
    getAreaValue: function(panel, area, name) {
        var val = null;
        if (panels[panel] != null && panels[panel].spc.area['area.' + area]) {
            if (name == 'arm_mode_value') {
                val = panels[panel].spc.area['area.' + area]['arm_mode'].value;
            } else if (name == 'arm_mode') {
                var mode = panels[panel].spc.area['area.' + area]['arm_mode'].value;
                var detail = st.spcAreaModes[mode];
                val = st.spcAreaModesText[locale][detail];
            }
            else if (name == 'alarm') {
                val = panels[panel].spc.area['area.' + area]['alarm'].value;
            }
        }
        return val;
    },

    // Set the arm state of the area
    setAreaArmMode: function(panel, area, mode, callback) {
        if (panels[panel] != null && panels[panel].spc.settings.areas[area] != null) {
            var allowed = true;   // TODO Handle allow variable
            if (allowed && panels[panel].spc.readAllSettings) {
                panels[panel].spc.sendCommand('area/' + area + '/' + mode, function(err, success) {
                   callback(err, success);
                });
            } else {
                callback('Not allowed');
            }
        } else {
            callback('Panel or Area does not exist');
        }
    },

    // Add a sensor device
    addSensorDevice: function(driver, device, name) {
        var panel = device.panel;
        var data = {
            type: 'sensor',
            driver: driver,
            device: device,
            name: name
        };
        if (panels[panel] != null) {
            debug("Adding device " + device.id);
            panels[panel].children.push(data);
            var did = device.id.split(':');
            panels[panel].spc.events.on('zone.' + did[1], function(field, newVal, curVal) {
                debug('Zone event', field, 'with new value: ', newVal, ', currrent value: ', curVal);
                var cur = undefined;
                if (curVal != undefined) cur = curVal.value;
                var now = new Date().toLocaleString(locale);
                if (field == 'state') {
                    if (newVal) {
                        driver.getDevice(device).setSettings({
                            state: now
                        });
                    }
                    driver.getDevice(device).setCapabilityValue('zone_state', st.spcZoneInputs[newVal.value], function(err, success) {
                        debug('Capability update event', 'zone_state', 'zone', did[1] + ':', (err ? err : 'OK'));
                    });
                    driver.triggerZoneStateTo(driver.getDevice(device), {}, {value:newVal.value, current:cur});
                    driver.triggerZoneStateFrom(driver.getDevice(device), {}, {value:newVal.value, current:cur});
                } else if (field == 'status') {
                    if (newVal) {
                        driver.getDevice(device).setSettings({
                            status: now
                        });
                    }
                    driver.getDevice(device).setCapabilityValue('zone_status', st.spcZoneStatus[newVal.value], function(err, success) {
                        debug('Capability update event', 'zone_status', 'zone', did[1] + ':', (err ? err : 'OK'));
                    });
                    driver.triggerZoneStatusTo(driver.getDevice(device), {}, {value:newVal.value, current:cur});
                    driver.triggerZoneStatusFrom(driver.getDevice(device), {}, {value:newVal.value, current:cur});

                    var alarm = false;
                    if (newVal.value >= 3) alarm = true;  // Soak, Tamper, Alarm, Trouble
                    driver.getDevice(device).setCapabilityValue('zone_alarm', alarm, function(err, success) {
                        debug('Capability update event', 'zone_alarm', 'zone', did[1] + ':', (err ? err : 'OK'));
                    });

                    if (curVal != undefined && curVal.value != newVal.value) {
                        if (alarm) {
                            driver.triggerZoneAlarmOn(driver.getDevice(device), {}, {});
                        } else {
                            driver.triggerZoneAlarmOff(driver.getDevice(device), {}, {});
                        }
                    }
                }
            });
        } else {
            addToQueue(panel, data);
        }
    },

    // Add a alarm area device
    addAreaDevice: function(driver, device, name) {
        var panel = device.panel;
        var data = {
            type: 'area',
            driver: driver,
            device: device,
            name: name
        };
        if (panels[panel] != null) {
            debug("Adding device " + device.id);
            panels[panel].children.push(data);
            var did = device.id.split(':');
            panels[panel].spc.events.on('area.' + did[1], function(field, newVal, curVal) {
                var now = new Date().toLocaleString(locale);
                debug('Area event', field, 'with new value: ', newVal, ', current value: ', curVal);
                var cur = undefined;
                if (curVal != undefined) cur = curVal.value;
                if (field == 'arm_mode') {
                    // area_id = Area number
                    // mode = 0 - 3. Unset, Partset A, PartsetB, Fullset
                    if (newVal) {
                        driver.getDevice(device).setSettings({
                            status: now
                        });
                    }
                    var detail = st.spcAreaModes[newVal.value];
                    var detailTxt = st.spcAreaModesText[locale][detail];
                    driver.getDevice(device).setCapabilityValue('arm_mode', detailTxt, function(err, success) {
                        debug('Capability arm_mode update:', 'area.' + did[1], (err ? err : 'OK'));
                    });
                    driver.triggerAreaModeTo(driver.getDevice(device), {}, {value:newVal.value, current:cur});
                    driver.triggerAreaModeFrom(driver.getDevice(device), {}, {value:newVal.value, current:cur});
                }
                else if (field == 'alarm') {
                    if (newVal) {
                        driver.getDevice(device).setSettings({
                            alarm: now
                        });
                    }
                    driver.getDevice(device).setCapabilityValue('alarm', newVal.value, function(err, success) {
                        debug('Capability area alarm state:', 'area.' + did[1], (err ? err : 'OK'));
                    });
                    if (curVal != undefined && curVal.value != newVal.value) {
                        if (newVal.value) {
                            driver.triggerAreaAlarmOn(driver.getDevice(device), {}, {});
                        } else {
                            driver.triggerAreaAlarmOff(driver.getDevice(device), {}, {});
                        }
                    }
                }
            });
        } else {
            addToQueue(panel, data);
        }
    },

    // Delete a sensor
    deleteSensorDevice: function(device) {
        debug('Deleting device', device.id);
        var panel = device.panel;
        if (panels[panel] != null) {
            for (var i = 0; i < panels[panel].children.length; i++) {
                if (panels[panel].children[i].device.id == device.id) {
                    var dev = panels[panel].children[i];
                    panels[panel].children.splice(i, 1);
                }
            }
            // Remove events
            var did = device.id.split(':');
            panels[panel].spc.events.removeAllListeners('zone.' + did[1]);
        }
    },

    // Delete an Area
    deleteAreaDevice: function(device) {
        debug('Deleting area device', device.id);
        var panel = device.panel;
        if (panels[panel] != null) {
            for (var i = 0; i < panels[panel].children.length; i++) {
                if (panels[panel].children[i].device.id == device.id) {
                    var dev = panels[panel].children[i];
                    panels[panel].children.splice(i, 1);
                }
            }
            // Remove events
            var did = device.id.split(':');
            panels[panel].spc.events.removeAllListeners('area.' + did[1]);
        }
    },

    // Update the end-user name of the device
    updateDeviceName: function(device_data, name) {
        var panel = device_data.panel;
        var device_id = device_data.id;
        if (panels[panel] != null) {
            for (var i = 0; i < panels[panel].children.length; i++) {
                if (panels[panel].children[i].device.id == device_id) {
                    panels[panel].children[i].name = name;
                }
            }
        }
    },

    // Get all areas the panel has registered
    getAreas: function(panel) {
        var items = [];
        if (panels[panel] != null) {
            var list = panels[panel].spc.settings.areas;
            if (panels[panel].spc.readAllSettings) {
                for (var idx in list) {
                    var elem = list[idx];
                    var setting = {
                        area: elem.area_id,
                        name: elem.area_name
                    };
                    items.push({
                        name: elem.area_name + ' (area ' + elem.area_id + ')',
                        data: {
                            id: 'area:' + idx,
                            panel: panel,
                            area: idx
                        },
                        settings: setting
                    });
                }
            }
        }
        return items;
    },

    // Get all zones the panel has registered
    getZones: function(panel) {
        var items = [];
        if (panels[panel] != null) {
            var list = panels[panel].spc.settings.zones;
            if (panels[panel].spc.readAllSettings) {
                for (var idx in list) {
                    var elem = list[idx];
                    var setting = {
                        zone: idx,
                        name: elem.zname,
                        type: elem.ztypeName,
                        area: elem.area.join(', ')
                    };
                    items.push({
                        settings: setting
                    });
                }
            }
        }
        return items;
    },

    // Get all sensors the panel has registered (and is not already added)
    getSensors: function(panel, type) {
        var items = [];
        if (panels[panel] != null) {
            var list = panels[panel].spc.settings.zones;
            if (panels[panel].spc.readAllSettings) {
                for (var idx in list) {
                    var elem = list[idx];
                    var setting = {
                        zone: idx,
                        name: elem.zname,
                        type: elem.ztypeName,
                        area: elem.area.join(', ')
                    };
                    if (type == 'door' && elem.stype == 'generic' &&
                        !deviceIsAdded(panel, 'sensor', idx)) { // Check that it is not already added
                        items.push({
                            name: elem.zname + ' (zone ' + idx + ')',
                            data: {
                                id: 'door:' + idx,
                                panel: panel,
                                zone: idx
                            },
                            settings: setting
                        });
                    } else if (type == 'window' && elem.stype == 'generic' &&
                        !deviceIsAdded(panel, 'sensor', idx)) { // Check that it is not already added
                        items.push({
                            name: elem.zname + ' (zone ' + idx + ')',
                            data: {
                                id: 'window:' + idx,
                                panel: panel,
                                zone: idx
                            },
                            settings: setting
                        });
                    } else if (type == 'motion' && elem.stype == 'generic' &&
                        !deviceIsAdded(panel, 'sensor', idx)) { // Check that it is not already added
                        items.push({
                            name: elem.zname + ' (zone ' + idx + ')',
                            data: {
                                id: 'motion:' + idx,
                                panel: panel,
                                zone: idx
                            },
                            settings: setting
                        });
                    } else if (type == 'smoke' && elem.stype == 'fire') {
                        items.push({
                            name: elem.zname + ' (zone ' + idx + ')',
                            data: {
                                id: 'smoke:' + idx,
                                panel: panel,
                                zone: idx
                            },
                            settings: setting
                        });
                    }
                }
            }
        }
        return items;
    },

    // Get a sensor value
    getZoneValue: function(panel, zone_id, name) {
        if (panels[panel] != null) {
            var zone = 'zone.' + zone_id;
            var val = null;
            if (panels[panel].spc.zone[zone] != null) {
                if (name == 'zone_alarm') {
                    var v = panels[panel].spc.zone[zone].status.value;
                    val = false;
                    if (v >= 3) val = true;
                } else if (name == 'zone_state_value') {
                    val = panels[panel].spc.zone[zone].state.value;
                } else if (name == 'zone_state') {
                    var v = panels[panel].spc.zone[zone].state.value;
                    val = st.spcZoneInputs[v];
                } else if (name == 'zone_status_value') {
                    val = panels[panel].spc.zone[zone].status.value;
                } else if (name == 'zone_status') {
                    var v = panels[panel].spc.zone[zone].status.value;
                    val = st.spcZoneStatus[v];
                }
            }
            return val;
        } else {
            // Panel has been removed
            debug('Panel does not exist');
            return val;
        }
    },

    // Get the name of the zone
    getZoneName: function(panel, zone) {
        var name = locale == 'en' ? 'Unknown' : 'Onbekend';
        if (panels[panel] != null) {
            var zones = panels[panel].spc.settings.zones;
            if (zones != null && zones[zone] != null) {
                name = zones[zone].zname;
            }
        }
        return name;
    },

    // Get the list of open zones
    getOpenZones: function(panel) {
        var zones = [];
        if (panels[panel] != null) {
            // We only list sensors that are visible in Homey
            for (var i = 0; i < panels[panel].children.length; i++) {
                if (panels[panel].children[i].type == 'sensor') {
                    var zonenr = panels[panel].children[i].device.zone;
                    var zone = panels[panel].spc.zone['zone.' + zonenr];
                    if (zone != null && zone.trip) {
                        var sensordriver = panels[panel].children[i].driver;
                        zones.push({
                            nr: zonenr,
                            name: panels[panel].children[i].name
                        });
                    }
                }
            }
        }
        return zones;
    }
}
