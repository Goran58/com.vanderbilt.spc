"use strict";

const st = require('./spc_tables.js');
const event = require('events');

const digest = require('http-digest-client');
const websocket = require('ws');

const Homey = require('homey');
//const locale = Homey.ManagerI18n.getLanguage();

// Update a variable only if the value will change
var updateStatus = function(self, what, field, newVal) {
    var type = what.split('.')[0];
    var curVal = null;
    var changed = false;
    if (type == 'zone') {
        if (self.zone[what] == null) {
            self.zone[what] = {};
        }
        curVal = self.zone[what][field];
        changed = curVal != null && typeof newVal == 'object' ? newVal.value != curVal.value : newVal != curVal;
        if (changed) {
           self.zone[what][field] = newVal;
           self.events.emit(what, field, newVal, curVal);
           return true;
        }
       
    } else if (type == 'area') {
        if (self.area[what] == null) {
            self.area[what] = {};
        }
        curVal = self.area[what][field];
        changed = curVal != null && typeof newVal == 'object' ? newVal.value != curVal.value : newVal != curVal;
        if (changed) {
           self.area[what][field] = newVal;
           self.events.emit(what, field, newVal, curVal);
           return true;
        }
    } else if (type == 'system') {
        if (self.system[what] == null) {
            self.system[what] = {};
        }
        curVal = self.system[what][field];
        changed = curVal != null && typeof newVal == 'object' ? newVal.value != curVal.value : newVal != curVal;
        if (changed) {
           self.system[what][field] = newVal;
           self.events.emit(what, field, newVal, curVal);
           return true;
        }
    }
    return false;
}
// Update SPC zone status
var updateSpcZoneStatus = function(self, siaCode, zoneId, zoneName, eventId) {
    var value = 0;
    if (siaCode == 'BB' || siaCode == 'BU') { // Isolate/Deisolate or Inhibit/Deinhibit
        self.debug("Received zone (De)isolate or (De)inhibit message");
        var status = 0;
        if (siaCode == 'BB' && eventId == 1600) {
            status = 2; // Zone Isolate
        } else if (siaCode == 'BB') {
            status = 1; // Zone Inhibit
        } else if (siaCode == 'BU') {
            status = 0; // Deisolate or Deinhibit
        }
        if (self.settings.zones[zoneId] != null) {
            if (updateStatus(self, 'zone.' + zoneId, 'status', { zone_id: zoneId, value: status })) {
                self.debug('Updating status for zone device ' + zoneId + ' (' + status + ')');
            }
        }
    } else if (siaCode == 'ZC' || siaCode == 'ZO' || siaCode == 'ZD') { // Zone closed/open or disconnect
        self.debug("Received zone open/close status or disconnect message");
        if (self.settings.zones[zoneId] != null) {
            var state = 0;
            if (siaCode == 'ZO') state = 1;
            if (siaCode == 'ZD') state = 3;
            if (updateStatus(self, 'zone.' + zoneId, 'state', { zone_id: zoneId, value: state })) {
                self.debug('Updating state for zone device ' + zoneId + ' (' + state + ')');
            }
        }
    }
    else {
        return false;
    }
    return true;
}

// Handle Status
var handleStatus = function(self, data) {
    var eventId = data.event.ev_id;
    var siaCode = data.event.sia_code;
    var siaAddress = data.event.sia_address;
    var zoneName = data.event.zone_name;

    /* For specific events do a complete update of area and zone status
       BA/BR = Burglary alarm/restore, BT/BJ = Zone tamper/restore,
       CG = Fullset, CL = Fail to set, FA/FR = Fire alarm/restore,
       LX = Engineer logout, NL = Partset , OP = Unset, OG = Post alarm set
    */
    if (siaCode == 'BA' || siaCode == 'BR' || siaCode == 'BT' || siaCode == 'BJ' ||
        siaCode == 'CG' || siaCode == 'CL' || siaCode == 'FA' || siaCode == 'FR' ||
        siaCode == 'LX' || siaCode == 'NL' || siaCode == 'OP' || siaCode == 'OG') {
        self.getAllStatus(function(err, success) {
           if (success) {
               self.debug('getAllStatus', success); 
           } else {
               self.debug('getAllStatus', err); 
           }
        });
    }
    /* Zone specific events that can be handled without complete update
       BB/BU = Zone inhibit or isolate/deinhibit or deisolate, ZC/ZO = Zone close/open,
       ZD = Zone disconnected
    */
    else if (siaCode == 'BB' || siaCode == 'BU' || siaCode == 'ZC' || siaCode == 'ZO' ||
        siaCode == 'ZD') {
        updateSpcZoneStatus(self, siaCode, siaAddress, zoneName, eventId);
    }
}
// Update panel area mode according to the mode of the areas
var updatePanelAreaMode = function(self) {
    var mode = null;
    for (var area_id in self.settings.areas) {
        if (mode == null) {
            mode = self.area['area.' + area_id].arm_mode.value;
        } else {
            if (self.area['area.' + area_id].arm_mode.value != mode) {
                mode = 99;  // Modes differs between areas - Partly set
                break;
            }
        }
    }
    if (updateStatus(self, 'system', 'arm_mode', {value: mode})) {
        self.debug('Updating arm_mode for panel  (' + mode + ')');
    }
}

// Update areas and panel alarm states according to the zones alarm states
var updatePanelAlarmStates = function(self) {
    var panel_alarm_state = false;
    for (var area_id in self.settings.areas) {
        var area_alarm_state = false;
        for (var zone_id in self.settings.zones) {
            if (self.settings.zones[zone_id].area[0] == area_id &&
                self.zone['zone.' + zone_id] &&
                self.zone['zone.' + zone_id].status.value >= 3) {  // Soak, Tamper, Alarm, Trouble
                area_alarm_state = true;
                break;
            }
        }
        if (updateStatus(self, 'area.' + area_id, 'alarm', {value: area_alarm_state})) {
            self.debug('Updating area alarm state for area ' + area_id + ' (' + area_alarm_state + ')');
        }
        if (area_alarm_state) panel_alarm_state = true;
    }
    if (updateStatus(self, 'system', 'alarm', {value: panel_alarm_state})) {
        self.debug('Updating panel alarm state (' + panel_alarm_state + ')');
    }
}


// Main constructor
function Spc(id, settings, debug) {

    var self = this;
    this.id = id;
    this.ip_port = settings.bridge_ip + ':' + settings.bridge_port;
    this.forceModel = settings.forceModel || 'auto';
    this.devSettings = settings;
    this.debug = function() {
        debug('[' + self.ip_port + ']', arguments);
    };
    this.wsclient;
    this.found = (id == null ? 'no' : 'yes');
    this.reconnectTimer;
    this.events = new event.EventEmitter();
    this.settings = {
        state: this,
        debug: this.debug,
        config: {},    // Panel configuration
        areas: {},     // Area information
        zones: {},     // Zone information
        outputs: {}    // Output information
    };
    this.readAllSettings = false;
    this.readAllStatus = false;
    this.downloadState;
    this.area = {};    // State of each area
    this.zone = {};    // State of each zone
    this.system = {};  // System states
    this.motionTimeout = [];

    this.events.setMaxListeners(0); // infinity
    this.events.on('download', function(state) {
        self.downloadState = state; // can be 'start', 'failed' or 'done'
    });

    this.getConfig(function(err, success) {
        if (err) {
            self.events.emit('found', {found: false});
            self.debug('getConfig', err);
        } else {
            self.events.emit('found', {found: true});
            // Wait some time to let everything settle before get and
            // update current status
            setTimeout(function() {
                self.events.emit('download', 'done');
            }, 10000);
        }
    });
}

Spc.prototype.spcRequest = function(method, uri, callback) {
    var user, password;
    if (method == 'GET') {
        user = this.devSettings.get_user;
        password = this.devSettings.get_password;
    } else if (method == 'PUT') {
        user = this.devSettings.put_user;
        password = this.devSettings.put_password;
    } else {
        return;
    }

    var spc_http_client = digest.createClient(user, password, true);
    var options = {
        host: this.devSettings.bridge_ip,
        port: this.devSettings.bridge_port,
        path: '/spc/' + uri,
        method: method
    }
    var reply = "";

    var req = spc_http_client.request(options, function(res, err) {
        if (err) {
            callback('{}', true);
        } else {
            res.setEncoding('utf8');
            res.on('data', function(chunk) {
                reply += chunk;
            });
            res.on('end', function() {
                if (callback) callback(reply, false);
            });
        }
    });
}

// Get configuration from SPC Panel
Spc.prototype.getConfig = function(callback) {
    var self = this;

    // Panel Info
    this.spcRequest('GET', 'panel', function(reply, err) {
        if (err || reply == null || reply.length == 0) {
            callback('Unable to get panel configuration', null);
            return;
        }
        Promise.resolve(JSON.parse(reply)).then(d => {
            if (d && d.status === 'success') {
                var panel = d.data.panel_summary;
                self.settings.config.panelType = panel.spc_type;
                self.settings.config.panelModel = panel.spc_variant;
                self.settings.config.panelSerial = panel.spc_serial_no;
                self.settings.config.panelSoftware = panel.spc_fw_version;

                // Area Info
                self.spcRequest('GET', 'area', function(reply, err) {
                    if (err || reply == null || reply.length == 0) {
                        callback('Unable to get area configuration', null);
                        return;
                    }
                    Promise.resolve(JSON.parse(reply)).then(d => {
                        if (d && d.status === 'success') {
                            if (d.data.area_status && Array.isArray(d.data.area_status)) {
                                for (var i = 0; i < d.data.area_status.length; i++) {
                                    var area = d.data.area_status[i];
                                    self.settings.areas[area.area_id] = {
                                        area_id: area.area_id,
                                        area_name: area.area_name
                                    }
                                }
                            } else if (d.data.area_status) {
                                var area = d.data.area_status;
                                self.settings.areas[area.area_id] = {
                                    area_id: area.area_id,
                                    area_name: area.area_name
                                }
                            }

                            // Zone Info
                            self.spcRequest('GET', 'zone', function(reply, err) {
                                if (err || reply == null || reply.length == 0) {
                                    callback('Unable to get zone configuration', null);
                                    return;
                                }
                                Promise.resolve(JSON.parse(reply)).then(d => {
                                    if (d && d.status === 'success') {
                                        for (var i = 0; i < d.data.zone_status.length; i++) {
                                            var zone = d.data.zone_status[i];
                                            var ztypeName = st.spcZoneTypes[zone.type];
                                            var stype = 'generic';
                                            if (ztypeName == 'Fire' || ztypeName == 'Fire Exit') stype = 'fire';
                                            self.settings.zones[zone.zone_id] = {
                                                stype: stype,
                                                sid: 0,
                                                sname: null,
                                                ztype: zone.type,
                                                ztypeName: ztypeName,
                                                zname: zone.zone_name,
                                                area: [zone.area_id],
                                                area_name: zone.area_name
                                            }
                                        }
                                        self.readAllSettings = true;

                                        callback(null, 'Successfully get panel configuration');
                                    }
                                }).catch(err => {
                                    self.debug('Failed to parse get zone reply message');
                                    callback('Unable to get zone configuration', null);
                                })
                            });
                        }
                    }).catch(err => {
                        self.debug('Failed to parse get zone reply message');
                        callback('Unable to get zone configuration', null);
                    })
                });
            }
        }).catch(err => {
            self.debug('Failed to parse get area reply message');
            callback('Unable to get area configuration', null);
        })
    });

    return;
}
// Get all status from SPC Panel
Spc.prototype.getAllStatus = function(callback) {
    var self = this;
     self.readAllStatus = false;

    // Area status
    this.spcRequest('GET', 'area', function(reply, err) {
        if (err || reply == null || reply.length == 0) {
            self.debug('Failed to get area status');
            callback('Failed to get area status', null);
            return;
        }
        Promise.resolve(JSON.parse(reply)).then(d => {
            if (d && d.status === 'success') {
                if (d.data.area_status && Array.isArray(d.data.area_status)) {
                    for (var i = 0; i < d.data.area_status.length; i++) {
                        var area = d.data.area_status[i];
                        updateStatus(self, 'area.' + area.area_id, 'arm_mode', {
                            area_id: area.area_id,
                            value: area.mode
                        });
                    }
                } else if (d.data.area_status) {
                    var area = d.data.area_status;
                    updateStatus(self, 'area.' + area.area_id, 'arm_mode', {
                        area_id: area.area_id,
                        value: area.mode
                    });
                }

                // Update panel arm mode
                updatePanelAreaMode(self);

                // Zone status
                self.spcRequest('GET', 'zone', function(reply, err) {
                    if (err || reply == null || reply.length == 0) {
                        self.debug('Failed to get zone status');
                        callback('Failed to get zone status', null);
                        return;
                    }
                    Promise.resolve(JSON.parse(reply)).then(d => {
                        var d = JSON.parse(reply);
                        if (d && d.status === 'success') {
                            for (var i = 0; i < d.data.zone_status.length; i++) {
                                var zone = d.data.zone_status[i];
                                var zoneId = zone.zone_id;
                                if (self.settings.zones[zoneId] != null) {
                                    if (updateStatus(self, 'zone.' + zoneId, 'state', { zone_id: zoneId, value: zone.input })) {
                                        self.debug('Updating state for zone device ' + zoneId + ' (' + zone.input + ')');
                                    }
                                    if (updateStatus(self, 'zone.' + zoneId, 'status', { zone_id: zoneId, value: zone.status })) {
                                        self.debug('Updating status for zone device ' + zoneId + ' (' + zone.status + ')');
                                    }
                                }
                            }
                            // Update areas and panel alarm states
                            updatePanelAlarmStates(self);
                            self.readAllStatus = true;
                            callback(null, "success");
                        }
                    }).catch(err => {
                        self.debug('Failed to parse get zone status reply message');
                        callback('Failed to parse get zone status reply message', null);
                        return;
                    })
                });
            }
        }).catch(err => {
            self.debug('Failed to parse get area status reply message');
            callback('Failed to parse get area status reply message', null);
            return;
        })
    });

    return;
}
// Send commands to SPC Panel
Spc.prototype.sendCommand = function(command, callback) {
    var self = this;

    this.spcRequest('PUT', command, function(reply, err) {
        if (err || reply == null || reply.length == 0) {
            self.debug('Failed to send command');
            callback('Failed to send command');
            return;
        }
        Promise.resolve(JSON.parse(reply)).then(d => {
            if (d && d.status === 'success') {
                self.debug('Command OK', d.data);
                callback(null, true);
            }
            else {
                self.debug('Command failed', d.data);
                callback('Command failed');
            }
        }).catch(err => {
            self.debug('Failed to parse send command reply message');
            callback('Failed to parse send command reply message');
        })
    });
}

// Open Websocket communication to SPC Bridge
Spc.prototype.openWsConnection = function(callback) {
    var self = this;
    var host = this.devSettings.bridge_ip;
    var port = this.devSettings.bridge_port;
    var user = this.devSettings.ws_user;
    var password = this.devSettings.ws_password;
    var path = 'wss://' + host + ':' + port + '/ws/spc?username=' + user + '&password=' + password;
    this.wsclient = new websocket(path);

    this.wsclient.on('open', function() {
        self.debug('Websocket open');
        clearInterval(self.reconnectTimer);
        self.reconnectTimer = undefined;

        // Get current status
        self.getAllStatus(function(err, success) {
           if (success) {
               self.found = 'yes';
               self.events.emit('communication', 'open');
           }
           Homey.ManagerSettings.set('spc_bridge_data', self.devSettings);  // Set public API settings
           if (callback) callback(err, success); 
        });
    })

    this.wsclient.on('message', function(data, flags) {
        self.debug('Websocket message', data);
        self.processData(data);
    })

    this.wsclient.on('close', function() {
        self.debug('Websocket Closed', self.found);
        if (self.found != 'no' && self.reconnectTimer === undefined) {
            // Connection dropped, try to re-connect every 30 seconds
            self.reconnectTimer = setInterval(function() {
                self.debug('Re-connecting');
                self.openWsConnection();
            }, 30000);
        }
        self.events.emit('communication', 'closed');
        if (callback) callback('websocket closed', null);
    });

    this.wsclient.on('error', function(err) {
        self.debug('Websockets Error', err);
        if (self.found != 'no') {
            self.closeWsConnection();
        }
        self.events.emit('communication', 'error');
        if (callback) callback('websocket error', null);
    })
}

// Close the Websocket connection to SPC Gateway
Spc.prototype.closeWsConnection = function(callback) {
    this.debug('Close Websocket Connection');
    if (!this.wsclient) return;
    this.wsclient.close();
    this.found = (this.found == 'no' ? 'no' : 'yes');

    // Reset all variables
    this.readAllStatus = false;

    clearInterval(this.intervalTimer);
    this.intervalTimer = undefined;

    if (callback) callback(null, 'success');
}


// Process incoming event message from SPC
Spc.prototype.processData = function(data) {
    var self = this;
    Promise.resolve(JSON.parse(data)).then(d => {
        if (d && d.status === 'success') {
            // Handle the message
            handleStatus(self, d.data);
        } else {
            self.debug('Unhandled message', data);
        }
    }).catch(err => {
        self.debug('Failed to parse websocket event');
    })
};

module.exports = Spc;
